# Arrays

Arrays are a collection of elements, usually of the same type but not always.

```julia
julia> v = [1, 2, 3]  # array of integers
3-element Vector{Int64}:
 1
 2
 3

julia> w = [1.0, 2.0, 3.0]  # array of floats
3-element Vector{Float64}:
 1.0
 2.0
 3.0

julia> w = [1, 2.0, 3]  # the mixed array gets converted to Float64 because of the type promotion rules in Julia
3-element Vector{Float64}:
 1.0
 2.0
 3.0

julia> a = ["hello", 2.0, 3]  # mixed array has type Any
3-element Vector{Any}:
  "hello"
  2.0
  3
```

Notice that these arrays are of type `Vector{Int64}`, `Vector{Float64}`, and `Vector{Any}`.
The type `Vector` is a one-dimensional array in Julia. It is a subtype of `Array`.

```julia
julia> typeof(v)
Vector{Int64} (alias for Array{Int64, 1})

julia> typeof(w)
Vector{Float64} (alias for Array{Float64, 1})
```

### Questions
1. Try comparing arrays `v` and `w` using the comparison operators.
1. What is the output of `v isa Array`?


## Indexing arrays
You can access elements of an array using indexing.
Julia uses 1-based indexing, which means that the first element of an array is at index 1, not 0.

```julia
julia> a[1]  # indexing starts at 1, not 0
"hello"

julia> a[2]
2.0

julia> a[3]
3

julia> a[1] = 1  # you can change the value of an element in the array
1

julia> a
3-element Vector{Any}:
 1
 2.0
 3
```
The length of a vector can be obtained using the `length` function.

```julia
julia> length(a)
3
```


## Matrices
Matrices are two-dimensional arrays in Julia. You can create a matrix using the `reshape` function or by using semicolons to separate rows.

```julia
julia> A = [1 2 3; 4 5 6; 7 8 9]  # matrix with semicolons
3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9

julia> B = reshape(1:9, 3, 3)  # matrix with reshape
3×3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:
 1  4  7
 2  5  8
 3  6  9

julia> A[1, 2]  # indexing a matrix
2

julia> A[2, 3]
6

julia> A[1, :]  # all elements in the first row
3-element Vector{Int64}:
 1
 2
 3

julia> A[:, 1]  # all elements in the first column
3-element Vector{Int64}:
 1
 4
 7
```
You can also use the `size` function to get the dimensions of a matrix.

```julia
julia> size(A)
(3, 3)
julia> size(B)
(3, 3)
```

## Matrix and vector operations
You can perform various operations on matrices and vectors, such as addition, subtraction, multiplication, and division.

```julia
julia> A + B  # matrix addition
3×3 Matrix{Int64}:
  2   6  10
  6  10  14
 10  14  18

julia> A - B  # matrix subtraction
3×3 Matrix{Int64}:
 0  -2  -4
 2   0  -2
 4   2   0

julia> A * B  # matrix multiplication
3×3 Matrix{Int64}:
 14   32   50
 32   77  122
 50  122  194

julia> A / B  # matrix division
3×3 Matrix{Float64}:
 -0.333333   0.666667  -0.0
  2.26667   -7.53333    5.6
 -6.33333    6.66667   -0.0

julia> A'  # transpose of a matrix
3×3 adjoint(::Matrix{Int64}) with eltype Int64:
 1  4  7
 2  5  8
 3  6  9

julia> A * v  # matrix-vector multiplication. What do you think will happen?
3-element Vector{Int64}:
 14.0
 32.0
 50.0

julia> v * A  # what do you think will happen?
```
You can also perform element-wise operations using the `.*`, `./`, and `.^` operators.

```julia
julia> A .* B  # element-wise multiplication
3×3 Matrix{Int64}:
  1   8  21
  8  25  48
 21  48  81
```
There are more linear algebra operations available if you use the `LinearAlgebra` package.


## Broadcasting
Broadcasting allows you to apply a function to each element of an array or collection.
You can use the dot `.` operator to indicate that you want to apply a function element-wise.

```julia
julia> f(x) = 1 + x
f (generic function with 1 method)

julia> f(1)
2

julia> f(1.0)
2.0
```

What happens if we try to apply this function to a vector?
```julia
julia> v = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> f(v)
ERROR: MethodError: no method matching +(::Int64, ::Vector{Float64})
For element-wise addition, use broadcasting with dot syntax: scalar .+ array
The function `+` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  +(::Any, ::Any, ::Any, ::Any...)
   @ Base operators.jl:596
  +(::Real, ::Complex{Bool})
   @ Base complex.jl:322
  +(::Array, ::Array...)
   @ Base arraymath.jl:12
  ...

Stacktrace:
 [1] f(x::Vector{Float64})
   @ Main ./REPL[95]:1
 [2] top-level scope
   @ REPL[99]:1
```
The error message is telling us that the function `+` does not know how to add a scalar to a vector.
To fix this, we can use broadcasting with [dot syntax](https://docs.julialang.org/en/v1/manual/functions/#man-vectorized). This is also known as "element-wise" operations, "vectorized" operations, or "broadcasting".

```julia
julia> f.(v)  # apply f to each element of v
3-element Vector{Int64}:
 2
 3
 4
```

You can also use broadcasting with other functions.

```julia
julia> sin.(v)  # apply sin to each element of v
3-element Vector{Float64}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672
```

It is also possible to define a function that takes a vector as input and returns a vector as output.

```julia
julia> f(x) = x .+ 1  # broadcasting with dot operator
f (generic function with 1 method)
julia> f(v)
3-element Vector{Int64}:
 2
 3
 4
 ```

or using the `@.` macro

```julia
julia> @. f(x) = x + 1  # broadcasting with @. macro
f (generic function with 1 method)
julia> f(v)
3-element Vector{Int64}:
 2
 3
 4
```


## Functions with multiple arguments
It is more efficient in Julia to put code inside of functions.
This allows you to reuse code and avoid writing the same code over and over.
You can define functions with multiple arguments by separating the arguments with commas.

```julia
function add(x, y)
        return x + y
    end

add(1, 2)  # 3
```

Let's package an if statement and a for loop inside a function.

```julia
function print_numbers(n)
    for i in 1:n
        if i % 2 == 0
            println("$i is even")
        else
            println("$i is odd")
        end
    end
end

print_numbers(10)
```

This would have been tedious to write in the REPL.

