# Arrays

Arrays are a collection of elements, usually of the same type but not always.
Arrays in Julia are **mutable**, which means that you can change the elements of an array after it has been created.
A one-dimensional `Array` is called a `Vector` in Julia.

```julia
julia> v = [1, 2, 3]  # one-dimensional array (i.e. vector) of integers
3-element Vector{Int64}:
 1
 2
 3
```

If all the elements can be converted to the same type, Julia will infer the type of the array.
```julia
julia> [1, 2.2, 3]  # array of floats
3-element Vector{Float64}:
 1.0
 2.2
 3.0 
```

If the elements are of different types, Julia will use the most general type that can hold all the elements.
```julia
julia> a = ["hello", 2.0, 3, false, "ðŸŒµ"]  # mixed array has type Any
5-element Vector{Any}:
    "hello"
    2.0
    3
false
    "ðŸŒµ"
```

We can find out the number of elements in an array using the `length` function.
```julia
julia> length(a)
5
```


## Creating arrays
You can create arrays in other ways.
Using the `randn` function, you can create an array of random numbers from a normal distribution.
This is useful for creating gaussian noise in simulations.
We will use this later in the course.

```julia
julia> x = rand(3)  # array of 5 random numbers
3-element Vector{Float64}:
 0.5346195188930014
 0.630133797544507
 0.5654504803142291

julia> x = randn(3) # array of 5 random numbers from a normal distribution
3-element Vector{Float64}:
 -1.305609652029686
  0.7823283852517753
  0.5642076071244995
```

You can also create an array of zeros, ones, or an arbitrary value.
```julia
julia> zeros(3)  # array of 5 zeros
3-element Vector{Float64}:
 0.0
 0.0
 0.0

julia> ones(3)  # array of 5 ones
3-element Vector{Float64}:
 1.0
 1.0
 1.0

julia> fill(3.2, 5)
5-element Vector{Float64}:
 3.2
 3.2
 3.2
 3.2
 3.2
```

We can also use the `push!` function to add an element to the end of an array.

```julia
julia> push!(a, "-2")  # add a new element to the end of the array
6-element Vector{Any}:
    "hello"
    2.0
 false
    "ðŸŒµ"
    6
    "-2"
```

A useful way to use this is to create an empty array and then add elements to it with a `for` loop.
We can include a calculation in the loop and add the results to the array.
```julia
a = []
for x in 1:5
    y = x^2
    push!(a, y)
end
```


## Range objects
Range objects can also be used to create arrays.
The object `r = 1:10` is a `UnitRange` object that represents the numbers from 1 to 10 with step size 1.
You can also create a range object with a step size.
For example, `r = 1:2:10` represents the numbers from 1 to 10 with a step size of 2.
This is a `StepRange` object.

We can use the `dump` function to see the structure of an object. Try using `dump(r)` on the range object `r = 1:2:10`
and compare it to a `Vector` object created with `v = [1, 2, 3]`.
We can see that a `Vector` object is a one-dimensional array of elements, while a `UnitRange` object is a range of numbers with a start, stop, and step size.
It's a "lazy array" that doesn't store all of the numbers in memory.
This makes them very memory efficient.
See [this StackOverflow post](https://stackoverflow.com/questions/55438134/creating-arrays-from-ranges-in-julia-without-using-collect) for a detailed explanation.
When you use `collect(r)`, it creates a new array with the elements of the range object.

```julia
julia> v = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> dump(v)
Array{Int64}((3,)) [1, 2, 3]

julia> r = 1:2:10
1:2:9

julia> dump(r)
StepRange{Int64, Int64}:
  start: 1
  stop: 10
  step: 2

julia> dump(1:3)  # UnitRange is even lazier
UnitRange{Int64}
  start: Int64 1
  stop: Int64 3
```

You can also create a range object with more specificity by using the `range` function.
```julia
# create a range with a start value, end value, and step size
range(1, stop=10, step=2)

# create a range with a start value, step size, and length
range(1, step=0.5, length=5)  
```
Check out `?range` in the REPL to see all the options available for creating range objects.


### Exercises
1. Consider an array created as follows:

    ```julia
    x = 3
    my_array = [1, 2, x]
    ```
    What happens to `my_array` if `x` is changed after the array is created?

2. How do you create an array of 5 random numbers between 1 and 20 using the `rand` function? Can you make it a 2D array with 2 rows and 3 columns?


## Indexing and slicing
You can access elements of an array using *indexing*.
Julia uses 1-based indexing, which means that the first element of an array is at index 1 (many languages start at 0).

```julia
a = ["hello", 2.0, false, "ðŸŒµ", 6]
a[1]  # returns "hello"
a[2]  # returns 2.0
a[end-1]  # returns "ðŸŒµ"
```

Elements in a list can be reassigned using their index.
```julia
julia> v = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> v[1] = 10  # change the first element of the array
10

julia> v
3-element Vector{Int64}:
 10
  2
  3
```

Subarrays can be extracted by *slicing* with `i:j` notation.
```julia
a = ["hello", 2.0, false, "ðŸŒµ", 6]
a[1:2]  # returns ["hello", 2.0]
a[3:end]  # returns [false, "ðŸŒµ", 6]
```

We can step through the array with a step size.
Here, we step through the array with a step size of 2.
```julia
a = ["hello", 2.0, false, "ðŸŒµ", 6]
a[1:2:end]  # returns ["hello", false, 6]
```

We can also step *backwards* through the array using a step of -1.
```julia
a = ["hello", 2.0, false, "ðŸŒµ", 6]
a[end:-1:1]  # returns [6, "ðŸŒµ", false, 2.0, "hello"]
```


## Matrices
Matrices are two-dimensional arrays in Julia.
There are several ways to create two-dimensional arrays, but here is the easiest:

```julia
julia> [1 2 3; 4 5 6]  # matrix with semicolons
2Ã—3 Matrix{Int64}:
 1  2  3
 4  5  6
 ```

We can retrieve the dimensions of the matrix with the `size` function.
```julia
julia> size(B)
(2, 3)
```

Getting an element from the matrix is similar to getting an element from a vector, but we specify the row and column.
 ```julia
julia> A[2, 3]
6
```

You can also get a whole row or column of the matrix.
```julia
julia> A[1, :]  # all elements in the first row
3-element Vector{Int64}:
 1
 2
 3

julia> A[:, 1]  # all elements in the first column
3-element Vector{Int64}:
 1
 4
 7
```


## Iterating over arrays
Two common ways to iterate over an array are to iterate over each element in the array and iterate over each index, the position of the element.

```julia
fruits = ["apple", "banana", "cherry"]

for fruit in fruits
    println("Fruit: $fruit")
end

for index in eachindex(fruits)
    println("Index: $index")
end
```

If you need both the value and the index, you can use the `enumerate` function.
```julia
fruits = ["apple", "banana", "cherry"]
for (index, fruit) in enumerate(fruits)
    println("Index: $index, Fruit: $fruit")
end
```

There are special functions that allow you to iterate over rows and columns of a matrix
```julia
A = [1 2 3; 4 5 6; 7 8 9]
for row in eachrow(A)
    println(row)
end
for col in eachcol(A)
    println(col)
end
```


## Broadcasting
Broadcasting allows you to apply a function to each element of an array or collection.
Dot `.` syntax is a convenient notation to apply a function element-wise.
This is also known as [vectorizing](https://docs.julialang.org/en/v1/manual/functions/#man-vectorized) a function.
You can perform element-wise operations using the `.*`, `./`, and `.^` operators.
Let's see some examples.

```julia
julia> v = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> v .+ 1  # add 1 to each element of v
3-element Vector{Int64}:
 2
 3
 4

julia> sin.(v)
3-element Vector{Float64}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672
```

It is also possible to define a function that takes a vector as input and returns a vector as output.

```julia
v = [1, 2, 3]
f(x) = x .+ 1  # broadcasting with dot operator
f(v)  # returns [2, 3, 4]
```

or using the `@.` macro, another convenience feature.

```julia
julia> @. f(x) = x + 1  # broadcasting with @. macro
f (generic function with 1 method)

julia> f(v)
3-element Vector{Int64}:
 2
 3
 4
```


### Exercises
1. Consider the following function:

    ```julia
    f(x) = x^2 + 1
    ```
    What happens if you try to apply this function to an array?


## Comprehensions
Comprehensions are a powerful way to construct arrays.
In the following example, we create a new array with the squares of the even numbers from 0 to 5.
Here are some examples.

```julia
julia> [x^2 for x in 0:5]
6-element Vector{Int64}:
  0
  1
  4
  9
 16
 25
 
julia> [x^2 for x in 0:5 if iseven(x)]
3-element Vector{Int64}:
  0
  4
 16

julia> [i + j for i in 1:3, j in 1:3]
3Ã—3 Matrix{Int64}:
 2  3  4
 3  4  5
 4  5  6
 ```


### Exercises
1. Use a comprehension to create an array of numbers 1 to 100 that are divisible by 7.

2. Use an array comprehension to find all of the vowels in a string.


## Problems
1. Make a vector with the numbers 1 to 10 using array comprehension.

2. Use the vector that you made in the previous quesion. Write code that sets every even-indexed element of a vector `v` to 0. A list of `n` zeros can be created with `zeros(n)` or `fill(0, n)`.
*Challenge: Do this in one line of code without defining a new function!*


## Bonus: [Generator expressions](https://docs.julialang.org/en/v1/manual/arrays/#man-generators)
There are many ways to programmatically create arrays in Julia.
One way is to apply a function to each element of an array.
For example, if we want to apply a function `square` to each element of a vector containing integers from 0 to 5, we can use the `map` function.

```julia
square(x) = x^2
map(square, 0:5)  # returns [0, 1, 4, 9, 16, 25]
```
Another method is to filter the elements of an array.
For example, if we want to filter the even numbers from a vector containing integers from 0 to 5, we can use the `filter` function and the function `iseven` that returns true if a number is even.

```julia
filter(iseven, 0:5)  # returns [0, 2, 4]
```

Sometimes we don't want a lazy array. If we want each element in an array to be stored in memory, we can use the `collect` function.
```julia
collect(0:5)  # returns [0, 1, 2, 3, 4, 5]
```